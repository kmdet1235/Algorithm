<<Javascript Basic 개념정리>>

( Javascript는 느슨한 타입의 동적 언어 )

- 자바스크립트는 여덟가지 기본 <자료형>이 존재함
- 자바 스크립트에서 변수는 자료형에 관계없이 모든 데이터일 수 있음. 어떤 순간엔 문자열 일 수 있고, 다른땐 숫자가 될 수도 있음.
- 개발자가 변수의 타입을 지정하지 않음. 정확히 말하면 변수의 값에 따라 인터프리터가 알아서 변수의 타입을 파악하고 값을 저장함.
- 즉 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있기에 ‘동적 타입(dynamically typed)’언어라고함.


* {자료형}

— 기본형(Primitive) —

* 숫자형 – 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용. 정수의 한계는 ±2^53.
* bigint – 길이 제약 없이 정수를 나타낼 수 있음.(암호작업 같은 큰 숫자가 필요한 작업에 사용)
* 문자형 – 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용함. 단일 문자를 나타내는 별도의 자료형은 없음.(선언할 때 따옴표 사용, 
${…}안에 변수나 계산식을 넣어서 사용가능, java나 c언어는 문자형과 글자형을 따로 정의하지만 자바스크립트에서는 별도로 선언하지 않고 그냥 문자형만 있음)
* 불린형 – true, false를 나타낼 때 사용.
* null – null 값만을 위한 독립 자료형. null은 알 수 없는 값.(다른언어와 다른 의미를 가짐 자바스크립트에서는, 존재하지 않는(nothing)값, 비어있는(empty)값, 알 수 없는(unknown)값을 나타냄)
* undefined – undefined 값만을 위한 독립 자료형입니다. undefined는 할당되지 않은 값을 나타냄.

— 객체혐(Object) —

* 객체형 – 복잡한 데이터 구조를 표현할 때 사용.(다른 자료형은 문자열이든 숫자든 한 가지만 표현 할 수 있음)
* 심볼형 – 객체의 고유 식별자를 만들 때 사용.

* typeof 연산자는 피연산자의 자료형 유형을 알려줌(string인지 boolean인지 null etc.).
* typeof x 또는 typeof(x) 형태로 사용.
* 피연산자의 자료형을 문자열 형태로 반환.
/* null의 typeof 연산은 "object"인데, 언어상 오류임. null은 객체가 아닙니다.*/


자바스크립트 자료형 참고자료 :  https://ko.javascript.info/types



( Javascript의 특성(1) - 형변환 )

함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됨. 이 외에, 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이라고 할 수 있음.


* {문자형으로 변환} 

alert메소드는 매개변수로 문자형을 받기 때문에, alert(value)에서 value는 문자형이어야 함. 만약, 다른 값을 전달받으면 이 값은 문자형으로 자동 변환됨. 
문자형 변환은 주로 무언가를 출력할 때 주로 일어남. String(value)을 사용하면 문자형으로 명시적 변환이 가능.


* {숫자형으로 변환}

숫자형으로의 변환은 관련된 함수와 표현식에서 자동으로 일어남. 주로 수학 관련 연산에서 일어남. Number(value)로도 형 변환을 할 수 있음
일반적으로 아래와 같은 규칙을 가짐
——————————————————————————————
전달받은 값    |  형 변환 후
——————————————————————————————
undefined       NaN
Null		0
true/false	1/0
string		전달받은 문자열을 “그대로’ 읽지만 처음과 끝의 공백을 무시함.


* {불린형으로 변환}

논리연산(True/False)시 발생함. 
———————————————————————————————————————————————————————————————————————————————
          전달받은 값                   |               형 변환 후
———————————————————————————————————————————————————————————————————————————————
0, null, undefined,  NaN,””		     	     false
	그 외의 값					  true



( Javascript의 특성(2) - '==' vs '===' )

* {동등연산자'==' vs 일치연산자'==='} 

동등 연산자(equality operator) '=='은 '0'과 'false'를 구분못함.
동등 연산자 '=='가 형이 다른(숫자와 문자, 숫자와 불린 etc) 피연산자와 비교할때 피연산자를 숫자형으로 바꾸기 때문에 발생하는 현상.
빈 문자열과 'false'는 숫자형으로 변환하면 '0'이기 때문에 문제가 발생함.

>> 이를 해결하기 위해 일치 연산자(strict equality operator) '==='를 사용하면 형 변환 없이 값을 비교할 수 있음.
일치 연산자 '==='는 자료형의 동등 여부까지 검사하기 때문에 피연산자 a,b의 형이 다를경우 a === b 는 즉시 false를 반환함.



( Javascript의 특성(3) - 'undefined' vs 'null' )

* { 'undefined' vs 'null' 예시로 비교하기}

- alert( null === undefined ); // false
- alert( null == undefined ); // true

/* 산술 연산자나 비교연산자 '<, >, <=, >='를 사용하면 동등 연산자 처럼 'null'과 'unerfined'는 숫자형으로 변환됨.


* { null vs 0 }

- alert( null > 0 );  // (1) false
- alert( null == 0 ); // (2) false
- alert( null >= 0 ); // (3) true

>> (3)이 true가 나온 이유는 동등 연산자와 비교연산자의 동작방식이 다르기 때문. 동등연산자'=='는 'null','undefined'가
피연산자일때 형 변환을 하지 않음. 그렇기 때문에 (3)에서 비교연산자의 형 변환으로 null은 '0'으로 변환되어 '참'인 값이 됨.

* { undefined vs 0 }

- alert( undefined > 0 ); // false (1)
- alert( undefined < 0 ); // false (2)
- alert( undefined == 0 ); // false (3)

>> 'undefined'는 비교 자체가 불가능한 값. 'undefined'는 피연산자일때 비교연산자는 형 변환으로 'NaN'으로 변환되고,
'NaN'이 피연산자일때 비교 연산자는 항상 false 반환함.


** 일치 연산자 '==='를 제외한 비교 연산자의 피연산자에 'undefined'나 'null'이 오지 않도록 주의요함.
** 'undefined'나 'null'이 될 가능성이 있는 변수가 '<, >, <=, >='의 피연산자가 되지 않도록 주의 요함.
** 만약 변수가 'undefined'나 'null'이 될 가능성이 있다고 판단되면, 따로 처리하는 코드 추가 요함.