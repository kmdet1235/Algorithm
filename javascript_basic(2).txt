<<Javascript Basic 개념정리(2)>>

( Javascript의 객체와 불변성 )

- '원시형(primitive type)' 데이터는 오직 하나의 데이터(숫자, 문자열 등)만 담을 수 있음
- '객체형(object)'은 이와 달리 다양한 데이터를 담을 수 있음.
- '객체형'은 {...} 중괄호를 이용해서 만들며 '키(key)' : '값(value)'쌍으로 구성된 '속성(property)'을 여러개 넣을 수 있음
- '키'에는 문자형이, '값'에는 모든 자료형이 허용됨.


** 빈 객체 선언 예시
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

let user = new Object(); // '객체 생성자' 문법

let user = {};  // '객체 리터럴' 문법 : 중괄호를 사용하는 방법, 주로 사용됨

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


( 기본형 데이터와 참조형 데이터 )

- 객체와 원시 타입의 근본적인 차이는 '참조에 의해(by reference)'저장되고 복사가됨.
- 예를 들면, 아래와 같은 예시문에서 객체'user'는 메모리 어딘가에 저장되고, 'user'엔 '참조'할 수 있는 값이 저장됨

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

let user = { name: "John" };

let admin = user; // 참조값을 복사함

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

- 따라서 객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않음. 즉 변수는 두 개이지만 각 변수엔 동일한 참조값이 저장됨.
- 비유를 통해서 표현하자면, 서로 다른 두 사람이 각자 집을 가지고 있고 b는 a집에 있는 청소기를 빌려쓴다고 가정한다. 
  a의 청소기는 기본형이라 가정하고, b의 청소기는 참조형이라고 가정한다. a가 청소기를 바꾸고 싶어서 좋은 청소기가 있는 집으로 이사가는 것이
  기본형이고, b는 계속 a의 청소기를 빌려쓰다 다른 청소기를 사와서 집에 설치하는것이 참조형의 특징이라고 이해했음.
  ** 완전하진 않은 비유지만 이해하는데 약간 도움이 될까해서 써봤습니다.

- 참조를 비교하는 예시문을 통해 추가적으로 이해해보자면, 아래와 같은 예시에서는 두가지 변수가 모두 true인 값을 가지지만
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
let a = {};
let b = a; // 참조에 의한 복사

alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
alert( a === b ); // true
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  다른 예시로 보자면, a와 b는 서로 같지 않다. 서로서로 다른 집을 선언한 것이기에 두개의 값은 일치하지 않는다.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
let a = {};
let b = {}; // 독립된 두 객체

alert( a == b ); // false
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



( 불변 객체 만들기 )


* { 객체복사 }

- 위의 내용과 같이 데이터가 저장되고 복사됨으로써 참조형 데이터를 사용하는 변수는 기본형에 따라 값이 변하게됨
- 이런 사항을 보안하려면 독립적으로 해당 데이터를 받아서 저장해놓는 객체를 아래와 같이 만들면 됨.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 만들어짐.
clone.name = "Pete"; // clone의 데이터를 변경함.

alert( user.name ); // 기존 객체에는 여전히 John이 있게됨.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


* { Object.assign 복사 }

- 아래와 같은 함수를 사용해서 만들 수 있음
- dest는 목표로 하는 객체를 의미함
- src1, ... , srcN은 복사하고자하는 객체
- 객체 src1, ..., srcN의 프로퍼티를 dest에 복사하고 dest를 제와한 객체의 프로퍼티 전부가 첫번째 객체로 복사됨 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Object.assign(dest, [src1, src2, src3...])
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


* { 중첩 객체 복사 }

- 위의 사항들은 객체가의 프로퍼티가 원시값인 경우에만 해당됨
- 프로퍼티가 다른 객체에 대한 참조값인 경우도 존재함. 아래 예시와 같이.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- 이를 해결하기 위해 'key'의 값을 검사하면서 , 그 값이 객체인 경우 객체의 구조를 분석해서 복사하는 반복문을 사용해야함.
- 이와같은 방식을 '깊은 복사(deep cloning)'이라고함.